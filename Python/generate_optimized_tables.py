#!/usr/bin/env python3
"""
Generate optimized lookup tables for RetroPunks smart contracts.

This script generates:
1. CRC32 lookup table for LibBitmap.sol (256 entries, packed into 32 bytes32)
2. CDF (Cumulative Distribution Function) tables for Rarities.sol
"""

import struct


def generate_crc32_table():
    """Generate CRC32 lookup table using polynomial 0xEDB88320"""
    table = []
    polynomial = 0xEDB88320

    for i in range(256):
        crc = i
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ polynomial
            else:
                crc >>= 1
        table.append(crc)

    return table


def pack_crc32_as_bytes32():
    """Pack CRC32 table as 32 bytes32 constants (8 uint32 per bytes32)"""
    table = generate_crc32_table()

    # 256 entries / 8 entries per bytes32 = 32 bytes32
    lines = []
    for i in range(32):
        values = table[i * 8:(i + 1) * 8]
        # Pack as big-endian bytes32
        packed = b''.join(struct.pack('>I', v) for v in values)
        hex_str = packed.hex()
        var_name = f"CRC32_TABLE_{i:X}" if i < 16 else f"CRC32_TABLE_{i}"
        lines.append(f"    bytes32 private constant {var_name} = 0x{hex_str};")

    return '\n'.join(lines)


def hex_to_weights(hex_str):
    """Convert hex string to list of uint16 weights"""
    # Remove 0x prefix if present
    if hex_str.startswith('0x') or hex_str.startswith('0X'):
        hex_str = hex_str[2:]

    weights = []
    for i in range(0, len(hex_str), 4):
        weight = int(hex_str[i:i+4], 16)
        weights.append(weight)
    return weights


def weights_to_cdf(weights):
    """Convert individual weights to cumulative distribution function"""
    cdf = []
    cumsum = 0
    for w in weights:
        cumsum += w
        cdf.append(cumsum)
    return cdf


def cdf_to_hex(cdf):
    """Convert CDF list to packed hex string"""
    hex_parts = []
    for value in cdf:
        hex_parts.append(f"{value:04X}")
    return "0x" + "".join(hex_parts)


def generate_cdf_for_rarity(name, hex_str, total_weight):
    """Generate CDF hex string for a rarity table"""
    weights = hex_to_weights(hex_str)
    cdf = weights_to_cdf(weights)

    # Verify total matches
    if cdf[-1] != total_weight:
        print(f"Warning: {name} CDF sum {cdf[-1]} != expected {total_weight}")

    return cdf_to_hex(cdf), len(weights)


# ============ Rarity tables from Rarities.sol ============
RARITY_TABLES = {
    # Male rarities
    "M_SKIN": ("0000002300AF000C002D0037000E02EE02EE02EE02EE02EE02EE02EE02EE02EE02EE02EE02EE000800160010003C0012001E000A0050012C0078", 10000),
    "M_EYES": ("000000320064000B000B000B000B000B000B000B000B000B00FA00000000101D00190019101D007D01F401F4004C", 10000),
    "M_FACE_A": ("249500120010004B00100023000A000A0008000C00140008000C00C8003C000C000A000E00320016", 9973),
    "M_FACE_B": ("249500000000004B00100000000A000A0000000000000000000C00C80000000C0000000000320000", 9750),
    "M_FACE_C": ("249500120010004B00000023000000000000000C00140008000000C800000000000A000E00000016", 9795),
    "M_CHAIN": ("232800FA0019004B008C015E000A00320064", 10000),
    "M_EARRING": ("232800FA0019004B008C015E000A00320064", 10000),
    "M_MASK": ("253A001E001E001E001E001E002800190019001900190019001900190019000F000F000A000A000A000A000A", 10000),
    "M_SCARF": ("26AC0028001E001E", 10000),
    "M_HEADWEAR": ("03BB007E007E007E007E007E003E003E003E003E003E003E003E003E003E004400440044004400440044004400440044003000300030006E0010001000100010001000100010008200820082008200820096000600060006000600060006000601270012001200120012001200120012001200120069000F00420042004200420042000F000F000F000F000F000F000F000F000F001E01450040004000400040004000410003000F000F000F000F002200220022006400290029002900290029002900290032004B002D0014006400640064004E004E004E004E004E004E004E004E004B004B004B004B004B004B004B004B004B004B00260026002600260026002600260026000E000E000E000E000E000E000E000E000E0037004E004E004E004E01220010001000100010001000100010004B004B004B004B004B004B004B004B00050005000500050005000500050005", 10000),
    "M_EYEWEAR": ("03E801DB00160016001600160016000A000A000A000A000A000A000A000A002E002E002E002E002E002E002E002E002E002E002E0014001400140014001400140014001401DB00400040004000400040004000400040004000170118021C013D001C001C001C001C001C001C001C0190003E003E003E003E003E003E023A00040003000300050005000500050005000500050005007D007D0230000900090009000900E10045027401A900030003000300030003000300030003000300320032003200320032003200320032003200320032004000400040004000400040004000400040015B0021002100210021000500050005000500050005000500050005", 10000),
    "MOUTH_A": ("1FDB007D001E00C800320096009600FA0032000F0014000F001E0014002300320064000A001900640064012C0014", 10000),
    "MOUTH_B": ("1FDB007D001E00C800320096009600FA0032000F0014000000000000000000320064000A001900640064012C0014", 9900),
    "MOUTH_C": ("1FDB007D001E00C800320096009600FA0032000F0014000000000000000000320064000A001900000000012C0014", 9700),

    # Female rarities
    "F_SKIN": ("0000001900E1000F002D0041001402EE02EE02EE02EE02EE02EE02EE02EE02EE02EE02EE02EE00080019005A0016000A012C0096", 10000),
    "F_EYES": ("000000320064000B000B000B000B000B000B000B000B000B00FA001E001E001E001E001E001E001E001E00000000101D00190019101D007D01F401F4004B", 10239),
    "F_FACE_A": ("24A10010000C004B0010007D0023000A000A00080012000A0016000C00C8000C0014000E0008", 10000),
    "F_FACE_B": ("25C100000000004B001000000000000A000A0000000000000000000C00C8000C000000000000", 10000),
    "F_FACE_C": ("25620010000C004B0000000000230000000000000012000A0016000000C800000014000E0008", 10000),
    "F_CHAIN": ("232800FA0019004B008C015E000A00320064", 10000),
    "F_EARRING": ("232800FA0019004B008C015E000A00320064", 10000),
    "F_MASK": ("253F001E001E001E001E001E002800190019001900190019001900190019000F000A000A000A000A000A", 9990),
    "F_SCARF": ("26AC0028001E001E", 10000),
    "F_HEADWEAR": ("036700E1009200920092009200920049004900490049004900490049004900490050005000500050005000500050005000500040004000400096009600960096009600C80006000600060006000600060006001800180018001800180018001800180018000F001E0177004A004A004A004A004A0041000F000F000F000F00320032003200300030003000300030003000300032004B000300190028007400740074005A005A005A005A005A005A005A005A0055005500550055005500550055005500550055002C002C002C002C002C002C002C002C000A00190037005B005B005B005B01540057005700570057005700570057005700050005000500050005000500050005", 9997),
    "F_EYEWEAR": ("03C801DB00160016001600160016000A000A000A000A000A000A000A000A002E002E002E002E002E002E002E002E002E002E002E0014001400140014001400140014001401DB00400040004000400040004000400040004000170118021C013D001C001C001C001C001C001C001C0190003E003E003E003E003E003E023A00040003000300050005000500050005000500050005023000E10045027401A900030003000300030003000300030003000300320032003200320032003200320032003200320032004000400040004000400040004000400040015B0021002100210021000500050005000500050005000500050005", 9682),
}


def generate_all_cdfs():
    """Generate CDF constants for all rarity tables"""
    lines = []
    lines.append("    // ============ CDF Tables (Cumulative Distribution Function) ============")
    lines.append("    // Pre-computed for O(log n) binary search lookup")
    lines.append("")

    for name, (hex_str, total) in RARITY_TABLES.items():
        cdf_hex, count = generate_cdf_for_rarity(name, hex_str, total)
        lines.append(f"    bytes private constant {name}_CDF = hex\"{cdf_hex[2:]}\";")
        lines.append(f"    // {name}: {count} entries, total weight = {total}")
        lines.append("")

    return '\n'.join(lines)


def main():
    print("=" * 60)
    print("CRC32 Lookup Table for LibBitmap.sol")
    print("=" * 60)
    print(pack_crc32_as_bytes32())
    print()

    print("=" * 60)
    print("CDF Tables for Rarities.sol")
    print("=" * 60)
    print(generate_all_cdfs())

    # Also verify a few values
    print("\n" + "=" * 60)
    print("Verification")
    print("=" * 60)

    # Verify CRC32 table
    table = generate_crc32_table()
    print(f"CRC32[0] = 0x{table[0]:08X} (should be 0x00000000)")
    print(f"CRC32[1] = 0x{table[1]:08X} (should be 0x77073096)")
    print(f"CRC32[255] = 0x{table[255]:08X} (should be 0x2D02EF8D)")


if __name__ == "__main__":
    main()
